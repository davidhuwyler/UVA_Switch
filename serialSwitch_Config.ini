;=====================================================================================
 [BaudRateConfiguration]
;
;
; BAUD_RATES_WIRELESS_CONN
; Configuration of baud rates on wireless side from 0 to 3.
; Regarding the supported baud rates see implementation of hwBufIfConfigureBaudRate in
; hwBufferInterface.cpp
BAUD_RATES_WIRELESS_CONN = 57600, 57600, 57600, 57600
;
;
; BAUD_RATES_DEVICE_CONN
; Configuration of baud rates on wireless side from 0 to 3.
; Regarding the supported baud rates see implementation of hwBufIfConfigureBaudRate in
; hwBufferInterface.cpp
BAUD_RATES_DEVICE_CONN = 38400, 38400, 38400, 38400
;
;
;=====================================================================================
[ConnectionConfiguration]
;
; PRIO_DEVICE
; Priority of the different Devices
; 0: Wireless connection is not used; 1: Highes priority; 2: Second priority, ..
PRIO_DEVICE = 1, 0, 0, 0
;
;=====================================================================================
[TransmissionConfiguration]
;
;
; RESEND_DELAY_WIRELESS_CONN [ms]
; Time in ms that should be waited until a package is sent again when no acknowledge is
; received
RESEND_DELAY_WIRELESS_CONN = 300
;
; RESEND_COUNT_WIRELESS_CONN [counts]
; Number of resend attempts beforethe package gets dumped
RESEND_COUNT_WIRELESS_CONN = 6
;
; USUAL_PACKET_SIZE_DEVICE_CONN [Bytes]
; Usual packet size per device in bytes if known or 0 if unknown.
USUAL_PACKET_SIZE_DEVICE_CONN = 50, 50, 50, 50
;
; PACKAGE_GEN_MAX_TIMEOUT [ms]
; Maximal time in ms that is waited until packet size is reached. If timeout is reached,
; the packet will be sent anyway, independent of the amount of the available data.
PACKAGE_GEN_MAX_TIMEOUT = 20, 20, 20, 20
;
; PAYLOAD_REORDERING_TIMEOUT [ms]
; This timeout configures, how long the program waits for the correct next
; package to arrive before sending the data out anyway (even with one package missing in; 
; the middle)
PAYLOAD_REORDERING_TIMEOUT = 2000
;
; USE_PROBING_PACKS [bool]
; If = 1, Probing packs for the evaluation of this Wireless link are generated
; If no probing packs are configured, the Link is only used if other Links fail.
USE_PROBING_PACKS = 1, 1, 1, 1
;
; COST_PER_PACKET_METRIC [int]
; If = 1, Probing packs are considered free of charge
; The higer the value, the more expensive is the link and the less likely the wirelesslink
, used
COST_PER_PACKET_METRIC = 1, 1, 1, 1
;
; USE_GOLAY_ERROR_CORRECTING_CODE
; Golay can correct up to xx bitflips, configuration per wireless side
USE_GOLAY_ERROR_CORRECTING_CODE = 0, 0, 0, 0
;=====================================================================================
[SoftwareConfiguration]
;
;
; TEST_HW_LOOPBACK_ONLY
; Set to 0 for normal operation, 1 in order to enable loopback on all serial interfaces in
; order to test the hardware.
TEST_HW_LOOPBACK_ONLY = 0
;
; ENABLE_STRESS_TEST
; Instead of reading bytes from device side, 10 bytes of data will be pushed onto the
; device RX queue on every SPI_HANDLER_TASK_INTERVAL
ENABLE_STRESS_TEST= 0
;
; GENERATE_DEBUG_OUTPUT
; The amount of debug output on the RTT Shell can be configured in three ways:
; 1 No debug output, RTT disabled, shell not configured
; 2 Only the shell is running, commands are parsed, no SW specifig debug output
; generated
; 3 Full debug output, throughput printout, prints any other SW specific debug
; information to RTT Client
GENERATE_DEBUG_OUTPUT = 3;
;
; LOGGING_ENABLED
; Set to 0 for normal operation, 1 in order to enable logging (might be less performant).
LOGGING_ENABLED = 0;
;
; SD_CARD_SYNC_INTERVAL
; Time in seconds between intervals where data from FAT buffer is flushed and written out
; to the SD card
SD_CARD_SYNC_INTERVAL = 1;
;
; SPI_HANDLER_TASK_INTERVAL
; Interval in [ms] of corresponding task which he will be called. 0 would be no delay - so
; to run as fast as possible.
SPI_HANDLER_TASK_INTERVAL = 5;
;
; PACKAGE_GENERATOR_TASK_INTERVAL
; Interval in [ms] of corresponding task which he will be called. 0 would be no delay - so
; to run as fast as possible.
PACKAGE_GENERATOR_TASK_INTERVAL = 5;
;
; NETWORK_HANDLER_TASK_INTERVAL
; Interval in [ms] of corresponding task which he will be called. 0 would be no delay - so
; to run as fast as possible.
NETWORK_HANDLER_TASK_INTERVAL = 3;
;
; NETWORK_METRICS_TASK_INTERVAL
; Interval in [ms] of corresponding task which he will be called. 0 would be no delay - so to run as fast as possible.
NETWORK_METRICS_TASK_INTERVAL	= 1000
;
; TRANSPORT_HANDLER_TASK_INTERVAL
; Interval in [ms] of corresponding task which he will be called. 0 would be no delay - so
; to run as fast as possible.
TRANSPORT_HANDLER_TASK_INTERVAL = 5;
;
; TOGGLE_GREEN_LED_INTERVAL
; Interval in [ms] in which the LED will be turned off or on -> frequency = 2xinterval
TOGGLE_GREEN_LED_INTERVAL = 500;
;
; THROUGHPUT_PRINTOUT_TASK_INTERVAL
; Interval in [s] in which the throughput information will be printed out
THROUGHPUT_PRINTOUT_TASK_INTERVAL = 60;
;
; SHELL_TASK_INTERVAL
; Interval in [ms] in which the shell task is called to print out debug information
SHELL_TASK_INTERVAL = 50;
;
; LOGGER_TASK_INTERVAL
; Interval in [ms] in which the logging task is called to save information on SD card
LOGGER_TASK_INTERVAL = 50;